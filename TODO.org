* General
** Most likely for the integration of proofs and code something like http://blog.objectteams.org/2010/02/ide-for-your-own-language-embedded-in-java-part-1/ is worth trying (to extend JDT at the points where there is no API/extension point for that)
*** alternatively, maybe the jdt weaving (http://wiki.eclipse.org/JDT_weaving_features) scala-ide uses is worth looking into?
** remove the introduced global state - DocumentState - plus everything that depends on that
*** especially important now that document might be modified without being the active editor window, and we should retract
** keep it simple, only one connection to a Coq binary
** future: incrementally run proofer in the background, annoy user then with unproven stuff (when code is changed)
** test cases/coverage - at least for parsers
** incremental combinator parsers, done in yi http://yi-editor.blogspot.com/2008/11/incremental-parsing-in-yi.html
** read scala style guide
** use mkString instead of reduceLeft at several places!
* Coq side
** Response/Message buffer (or below Goal Viewer?)
** clear Goal Buffer at right places
** Undo from just after End should jump to start of Section/Module/whatever
mobius approach to undo:
  public void undo(final ITopLevel itl) throws AProverException {
    if (isProofMode(itl)) {
      try {
        sendCommand(itl, "Undo 1.");
      }
      catch (Exception e) {
        sendCommand(itl, "Abort.");
      }
    }
    else {
      sendCommand(itl, "Back 1.");
    }
  }  
where isProofMode is CoqShellTokens.lemma.length != 0
** after undo, do syntax highlighting again!
** in Actions: search for "Proof." is wrong - better search for Definition/start of lemma. Proof is optional anyhow.
** unreliable with keyboard shortcuts -> look whether in action or not (otherwise risk error messages from coq)
** outline for eclipse
** syntax highlighting based on coq parser
*** source location information (hints at the bottom) - http://scala.sygneca.com/libs/parsing
*** Now works but based on Eclipse scanner rather than Coq parser.
** debug coq parser
** remove hack that searches for '. ' to send command
** retract proof/leave for later
*** especially Admitted/Abort/Abort All/Suspend/Resume
** Restore State/Write State support
*** to fight performance issues - being able to load current state again
*** might also help for background proofs
** interrupt on windows (custom c code which sends ctrl-c)
*** http://msdn.microsoft.com/en-us/library/ms811896
*** http://msdn.microsoft.com/en-us/library/ms683155(v=vs.85).aspx
** Reset ident <- undefines everything back to ident
** proof completion
*** start with SearchAbout and similar helpers
** dependency graph of coq files, run coqc as background task
** Progress as part of progress window, not custom dialog (without using Job API?)
*** real steps while GotoCursor/GotoEnd
*** add lemma name to progress (especially interesting for Qed.)
*** join strings (otherwise displays one line only, might be (* COMMENT *))
** scroll to document position (recenter while passing stuff to coq)
** resizable GoalViewer
*** syntax highlighting there
*** indentation
 losing whitespaces in CoqResponseParser
* Java side
** highlight verified/proven method in green or however
** add/remove whitespaces at end of class/file messes the coq synced output up (DeDefinition and emma instead of Definition and Lemma)
** Report Warnings/Errors instead of Console.println during parsing and simplification
** update on save rather than edit (and only if it typechecks/compiles ok)
** ignore Coq class in java output (at least partially)
** SimpleJava optimizations
observations from SnapshotTrees.java:
pushLeftPath: node = node.left (where node is an argument (must be allocated on stack anyhow?)) ~~> JAssignment(node, JFieldAccess(node, left)) ~~> tmp because node is used on RHS
      Node tmp_2 = node.left;
      node = tmp_2;
COUNTEREXAMPLE: x := x.foo + x.foo or x := foo(foo(x))
  ~~> reusing x hurts here
next: should be no tmp_5!
      Integer result
      [..]
      int tmp_5 = tmp_4.item
      result = tmp_5
next: cse:
      Node tmp_6 = nodestate.node;
      Node tmp_7 = tmp_6.rght;
      if (tmp_7 != null)
        Node tmp_8 = nodestate.node;
        Node tmp_9 = tmp_8.rght
        pushLeftPath(tmp_9)
same in contains: [item stack variable, integer argument ; node a local variable of type Node]
 if (node.item < item) ... else if (item < node.item)
 generates
   tmp_2 = FieldAccess(node, item)
   if (tmp_2 < item) ...
   else
     tmp_4 = FieldAccess(node, item)
     if (item < tmp_4)
~~> first conservative expansion into bad code, then later optimization of this!
 (means: remove variable tmp, conditionals from JBinding, JAssignment, JConditional)
method init_, new Node(i, l, r) vs new Node(i) <- also new should be followed by call to init
also, inner classes should be kept inner (how to do that in Coq?)
** operator translation (x += y --> x = x + y) (Composite)
** types for ternary Bool ? x : y <- intersect x y
** loop invariants (trees)
** proper syntax (not only a string) for pre/postcondition and loop invariants - plus completion!
** for loops -> translate to while
** foo.bar.baz() doesn't work properly (need to introduce multiple temporary variables and register these)
** error on multiple returns and overloading of the same method name
*** at least warnings for eclipse and support for refactoring/fixing these
** constructors (multiple, what to do in there?)
** static { } blocks
** field initializers
*** assign values in constructor
** multiple local variables: int foo, bar, baz
*** fails in assert(vars.length == 1) in TransformAST:FinishAST:transform
** copy fields + methods bodies from superclasses (once we have a strategy for class-to-class inheritance)
** there's an alternative way to get the source of an editor:
  final IEditorInput editorInput = window.getActivePage().getActiveEditor().getEditorInput();
  final IFile selectedFile = (IFile) editorInput.getAdapter(IFile.class);
* Java features
** Generics
** Exceptions
** array types
** dynamic casts
