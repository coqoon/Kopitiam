unreliable with keyboard shortcuts -> look whether in action or not (otherwise risk error messages from coq)
marker for coqposition
static methods are now supported by coq formalization!
remember adjectives of definitions (public/private/...)
ignore Coq class in java output (at least partially)
types for tmp_xx
* General
** remove the introduced global state - DocumentState - plus everything that depends on that
** keep it simple, only one connection to a Coq binary
** remove hack that first method of first class is in update
** future: incrementally run proofer in the background, annoy user then with unproven stuff (when code is changed)
** test cases/coverage - at least for parsers
** incremental combinator parsers, done in yi http://yi-editor.blogspot.com/2008/11/incremental-parsing-in-yi.html
* Coq side
** outline for eclipse
** syntax highlighting based on coq parser
*** source location information (hints at the bottom) - http://scala.sygneca.com/libs/parsing
*** Now works but based on Eclipse scanner rather than Coq parser.
** debug coq parser
** remove hack that searches for '. ' to send command
** retract proof/leave for later
*** especially Admitted/Abort/Abort All/Suspend/Resume
** Restore State/Write State support
*** to fight performance issues - being able to load current state again
*** might also help for background proofs
** interrupt on windows (custom c code which sends ctrl-c)
*** http://msdn.microsoft.com/en-us/library/ms811896
*** http://msdn.microsoft.com/en-us/library/ms683155(v=vs.85).aspx
** Reset ident <- undefines everything back to ident
** proof completion
* Java side
** loop invariants
** proper syntax (not only a string) for pre/postcondition and loop invariants - plus completion!
** for loops -> translate to while
** foo.bar.baz() doesn't work properly (need to introduce multiple temporary variables and register these)
** error on multiple returns and overloading of the same method name
** return type of java methods from java standard library (and other external libraries)
** static { } blocks
** field initializers
** multiple local variables: int foo, bar, baz
** copy fields + methods bodies from superclasses (once we have a strategy for class-to-class inheritance)
** dynamic casts
** there's an alternative way to get the source of an editor:
  final IEditorInput editorInput = window.getActivePage().getActiveEditor().getEditorInput();
  final IFile selectedFile = (IFile) editorInput.getAdapter(IFile.class);
* Java features
** Generics
** Exceptions
** array types
