* General
** remove the introduced global state - DocumentState - plus everything that depends on that
** keep it simple, only one connection to a Coq binary
** remove hack that first method of first class is in update
** future: incrementally run proofer in the background, annoy user then with unproven stuff (when code is changed)
** test cases/coverage - at least for parsers
* Coq side
** sometimes subgoals are only partially received, leading to CoqUnknown and partial/no display of subgoals (CoqTop/CoqResponse)
** outline for eclipse
** syntax highlighting based on coq parser
*** source location information (hints at the bottom) - http://scala.sygneca.com/libs/parsing
** debug coq parser
** remove hack that searches for '. ' to send command
** remove warning if it's void (source location has changed)
** disable undo if no undo possible
** retract proof/leave for later
** proof completion
** retract definition(s) for more steps of undo / look what Proof General does in that case
;; Simplified version of backtracking which uses state numbers, proof stack depth and
;; pending proofs put inside the coq (> v8.1) prompt. It uses the new coq command
;; "Backtrack". The prompt is like this:
;;      state                        proof stack
;;      num                           depth
;;       __                              _
;; aux < 12 |aux|SmallStepAntiReflexive| 4 < Ã¹
;; ^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^     ^
;; usual           pending proofs           usual 
;;                                          special char
;; exemple:
;; to go (back) from 12 |lema1|lema2...|leman| xx
;; to                8  |lemb1|lemb2...|lembm| 5
;; we must do "Backtrack 8 5 naborts" 
;; where naborts is the number of lemais that are not lembis

;; Rem: We could deal with suspend and resume with more work. We would need a new coq
;; command, because it is better to backtrack with *one* command (because
;; proof-change-hook used above is not exactly called at right times).

(defun  coq-find-and-forget-v81 (span)
  "Backtrack to SPAN.  Using the \"Backtrack n m p\" coq command."
  (let* (ans (naborts 0) (nundos 0)
            (proofdepth (coq-get-span-proofnum span))
            (proofstack (coq-get-span-proofstack span))
            (span-staten (coq-get-span-statenum span))
            (naborts (count-not-intersection coq-last-but-one-proofstack proofstack))
            )
    (setq ans
          (if (and ; this is more efficient as backtrack x y z may be slow
               (equal coq-last-but-one-proofstack proofstack)
               (= coq-last-but-one-proofnum proofdepth)
               (= coq-last-but-one-statenum span-staten))
              ""
            (format "Backtrack %s %s %s . " 
                    (int-to-string span-staten)
                    (int-to-string proofdepth)
                    naborts)))
    (if (string-equal ans "") proof-no-command ; not here because if
      ;; we backtrack a state preserving command, we must do
      ;; *nothing*, not even a CR (in > v74, no prompt is returned
      ;; with "\n")
      ans)
    )
  )

* Java side
** loop invariants
** proper syntax (not only a string) for pre/postcondition and loop invariants - plus completion!
** for loops
** foo.bar.baz() doesn't work properly (need to introduce multiple temporary variables and register these)
** error on multiple returns and overloading of the same method name
** return type of java methods from java standard library (and other external libraries)
** static { } blocks
** field initializers
** multiple local variables and fields: int foo, bar, baz
** copy fields + methods bodies from superclasses (once we have a strategy for class-to-class inheritance)
** dynamic casts
** there's an alternative way to get the source of an editor:
  final IEditorInput editorInput = window.getActivePage().getActiveEditor().getEditorInput();
  final IFile selectedFile = (IFile) editorInput.getAdapter(IFile.class);
* Java features
** Generics
** Exceptions
** array types

