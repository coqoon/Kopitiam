/* CoqMakefile.scala
 * Produce Coqoon-compatible Makefiles for Coq projects
 * Copyright Â© 2013 Alexander Faithfull
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License. */

package dk.itu.coqoon.core.project

import dk.itu.coqoon.core.model._

import org.eclipse.core.runtime.IPath
import org.eclipse.core.resources.{IProject, IResource}

private object CoqMakefile {
  def generateMakefile(project : IProject, dt : DependencyTracker) = {
    def makePathRelative(path : IPath) =
      CoqBuilder.makePathRelative(project.getLocation, path)

    val cp = ICoqModel.toCoqProject(project)
    val sb = new StringBuilder
    val isWeird = cp.getLoadPathProviders.exists(
        a => a.isInstanceOf[ProjectLoadPath] ||
             a.isInstanceOf[ExternalLoadPath] ||
             a.isInstanceOf[AbstractLoadPath])

    sb ++= "# Automatically generated by Coqoon -- do not edit directly!\n"
    if (isWeird)
      sb ++= """# Make site-specific changes in the CoqoonMakefile.vars file
# (using CoqoonMakefile.vars.template as a template).
"""

    sb ++= """
COQC = coqc
COQFLAGS = -noglob
override _COQCMD = \
\u0009mkdir -p "`dirname "$@"`" && $(COQC) $(COQFLAGS) "$<" && mv "$<o" "$@"

"""

    if (isWeird)
      sb ++= "include CoqoonMakefile.vars\n\n"

    def getFirstIdent(base_ : String, predicate : String => Boolean) = {
      val base = base_.toUpperCase.replaceAll("[^a-zA-Z0-9]+", "_")
      var name = base
      var i = 0
      while (predicate(name)) {
        name = base + "_" + i
        i += 1
      }
      name
    }

    var identifiers = Map[String, ICoqLoadPathProvider]()
    def escape(lp : CoqLoadPath) = makePathRelative(lp.path).map(
        a => Seq("-R", a.toString, lp.coqdir.getOrElse("")).map(
            CoqProjectEntry.escape)).get
    for (i <- cp.getLoadPathProviders) i match {
      case p @ DefaultOutputLoadPath(bin) =>
        sb ++= "override COQFLAGS += " +
            p.getLoadPath.flatMap(escape).mkString(" ") + "\n"
      case p @ SourceLoadPath(src, bin_) =>
        val bin = bin_.getOrElse(cp.getDefaultOutputLocation)
        sb ++= bin.getProjectRelativePath + "/%.vo: " +
          src.getProjectRelativePath + "/%.v\n\t$(_COQCMD)\n"
        sb ++= "override COQFLAGS += " +
            p.getLoadPath.flatMap(escape).mkString(" ") + "\n"
      case ExternalLoadPath(path, coqdir) =>
        val name = getFirstIdent(coqdir.getOrElse("external") + "_path",
            n => identifiers.contains(n))
        identifiers += (name -> i)
        sb ++= "override COQFLAGS += -R $(" + name + ") " +
            CoqProjectEntry.escape(coqdir.getOrElse("")) + "\n"
      case AbstractLoadPath(identifier) =>
        val name = getFirstIdent(identifier + "_flags",
            n => identifiers.contains(n))
        identifiers += (name -> i)
        sb ++= "override COQFLAGS += $(" + name + ")\n"
      case ProjectLoadPath(project) =>
        val name = getFirstIdent(project.getName + "_flags",
            n => identifiers.contains(n))
        identifiers += (name -> i)
        sb ++= "override COQFLAGS += $(" + name + ")\n"
    }

    import java.io.{ByteArrayInputStream => BAIS}

    /* Create the template for local configuration files */
    val tf = project.getFile("CoqoonMakefile.vars.template")
    if (isWeird) {
      val t = s"""# Automatically generated by Coqoon -- do not edit directly!

${identifiers.map(i => i._1 + " = ").mkString("\n")}
"""
      val content = new BAIS(t.getBytes("UTF-8"))
      if (tf.exists) {
        tf.setContents(content, IResource.NONE, null)
      } else tf.create(content, IResource.NONE, null)
    } else Option(tf).filter(_.exists).foreach(_.delete(IResource.NONE, null))

    /* Create a local configuration file */
    val lf = project.getFile("CoqoonMakefile.vars")
    if (isWeird) {
      val lb = new StringBuilder
      lb ++= "# Automatically generated by Coqoon -- do not edit directly!\n\n"

      for ((name, lpp) <- identifiers) lpp match {
        case ExternalLoadPath(path, _) =>
          lb ++= s"${name} = \\\n\t${path.toString}\n"
        case AbstractLoadPath(_) =>
          val escaped = lpp.getLoadPath.map(
              _.asArguments.map(CoqProjectEntry.escape).mkString(" "))
          lb ++= name + " = \\\n\t" + escaped.mkString(" \\\n\t") + "\n"
        case ProjectLoadPath(project) =>
          val escaped = lpp.getLoadPath.map(
              _.asArguments.map(CoqProjectEntry.escape).mkString(" "))
          lb ++= name + " = \\\n\t" + escaped.mkString(" \\\n\t") + "\n"
        case _ =>
      }

      val content = new BAIS(lb.result.getBytes("UTF-8"))
      if (lf.exists) {
        lf.setContents(content, IResource.NONE, null)
      } else lf.create(content, IResource.NONE, null)
    } else Option(lf).filter(_.exists).foreach(_.delete(IResource.NONE, null))

    val orderedDeps = dt.getDependencies.keys.toSeq.sortWith(
        (a, b) => a.toPortableString.compareTo(b.toPortableString) < 0)

    sb ++= "OBJECTS = " + orderedDeps.flatMap(makePathRelative).
        mkString("\\\n\t", " \\\n\t", "")
    sb ++= "\n\nall: $(OBJECTS)\nclean:\n\trm -f $(OBJECTS)\n\n"

    sb ++= (
      for (out <- orderedDeps;
           deps <- Some(dt.getDependencies(out));
           r <- makePathRelative(out))
        yield r + ": " + (
          for ((_, _, Some(path)) <- deps;
               r <- makePathRelative(path))
            yield r).mkString(" ")).mkString("\n")

    val result = new java.io.ByteArrayInputStream(sb.result.getBytes("UTF-8"))
    val f = project.getFile("CoqoonMakefile")
    if (f.exists) {
      f.setContents(result, IResource.NONE, null)
    } else f.create(result, IResource.NONE, null)
  }
}